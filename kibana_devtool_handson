GET _search
{
  "query": {
    "match_all": {}
  }
}
GET _cat/shards
GET _cat/nodes?v
GET _cluster/health?pretty
GET _cat/indices
PUT logstash-2021.07.05-000001
{
  "settings":{
    "number_of_shards":1,
    "number_of_replicas":0
  }
    
}
DELETE /products
POST /products/_doc
{
  "name":"phone",
  "price":64,
  "in_stock":100
}

PUT /products/_doc/100
{
  "name":"phone",
  "price":64,
  "in_stock":100
}
GET /products/_doc/100

POST /products/_update/100
{
  "doc":{
    "in_stock":103
  }
}
POST /products/_update/100
{
  "doc":{
    "tags":["electronics"]
  }
}


POST /products/_update/100
{
  "script": {
    "source": "ctx._source.in_stock--"
  }
}

POST /products/_update/100
{
  "script":{
    "source":"ctx._source.name = 'smartphone'"
  }
}
GET /products/_doc/100

POST /products/_update/100
{
  "script": {
    "source": "ctx._source.in_stock -= params.quantity",
    "params": {
      "quantity":4
    }
  }
}

POST /products/_update/100
{
  "script":{
    "source":"""
    if(ctx._source.in_stock==0){
      ctx.op='noop';
    }
    ctx._source.in_stock--;
    """
  }
}


PUT /_template/access-logs
{
  "index_patterns": ["access-logs*"],
  "settings": {
    "index.mapping.coerce": false
  }, 
  "mappings": {
    "dynamic": false,
    "properties": {
      "@timestamp": { "type": "date" },
      "message": { "type": "text" },
      "event.dataset": { "type": "keyword" },
      "hour_of_day": { "type": "short" },
      "http.request.method": { "type": "keyword" },
      "http.request.referrer": { "type": "keyword" },
      "http.response.body.bytes": { "type": "long" },
      "http.response.status_code": { "type": "long" },
      "http.version": { "type": "keyword" },
      "url.fragment": { "type": "keyword" },
      "url.path": { "type": "keyword" },
      "url.query": { "type": "keyword" },
      "url.scheme": { "type": "keyword" },
      "url.username": { "type": "keyword" },
      "url.original": {
        "type": "keyword",
        "fields": {
          "text": {
            "type": "text",
            "norms": false
          }
        }
      },
      "client.address": { "type": "keyword" },
      "client.ip": { "type": "ip" },
      "client.geo.city_name": { "type": "keyword" },
      "client.geo.continent_name": { "type": "keyword" },
      "client.geo.country_iso_code": { "type": "keyword" },
      "client.geo.country_name": { "type": "keyword" },
      "client.geo.location": { "type": "geo_point" },
      "client.geo.region_iso_code": { "type": "keyword" },
      "client.geo.region_name": { "type": "keyword" },
      "user_agent.device.name": { "type": "keyword" },
      "user_agent.name": { "type": "keyword" },
      "user_agent.version": { "type": "keyword" },
      "user_agent.original": {
        "type": "keyword",
        "fields": {
          "text": {
            "type": "text",
            "norms": false
          }
        }
      },
      "user_agent.os.version": { "type": "keyword" },
      "user_agent.os.name": {
        "type": "keyword",
        "fields": {
          "text": {
            "type": "text",
            "norms": false
          }
        }
      },
      "user_agent.os.full": {
        "type": "keyword",
        "fields": {
          "text": {
            "type": "text",
            "norms": false
          }
        }
      }
    }
  }
}




PUT /_template/orders
{
  "index_patterns": ["orders*"],
  "settings": {
    "index.mapping.coerce": false
  }, 
  "mappings": {
    "dynamic": false,
    "properties": {
      "@timestamp": { "type": "date" },
      "id": { "type": "keyword" },
      "product": {
        "properties": {
          "id": { "type": "keyword" },
          "name": { "type": "keyword" },
          "price": { "type": "float" },
          "brand": { "type": "keyword" },
          "category": { "type": "keyword" }
        }
      },
      "customer.id": { "type": "keyword" },
      "customer.age": { "type": "short" },
      "customer.gender": { "type": "keyword" },
      "customer.name": { "type": "keyword" },
      "customer.email": { "type": "keyword" },
      "channel": { "type": "keyword" },
      "store": { "type": "keyword" },
      "salesman.id": { "type": "keyword" },
      "salesman.name": { "type": "keyword" },
      "discount": { "type": "float" },
      "total": { "type": "float" }
    }
  }
}

cd test-data

curl -H "Content-Type: application/x-ndjson" -XPOST http://localhost:9200/_bulk --data-binary "@orders.bulk.ndjson"
curl -H "Content-Type: application/x-ndjson" -XPOST http://localhost:9200/_bulk --data-binary "@nginx-access-logs-2020-01.bulk.ndjson"
curl -H "Content-Type: application/x-ndjson" -XPOST http://localhost:9200/_bulk --data-binary "@nginx-access-logs-2020-02.bulk.ndjson"
curl -H "Content-Type: application/x-ndjson" -XPOST http://localhost:9200/_bulk --data-binary "@nginx-access-logs-2020-03.bulk.ndjson"


































#example of standard analyzer
PUT index_standard_analyzer
{
  "settings": {
    "analysis": {
      "analyzer": {
        "std": { 
          "type": "standard"
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "my_text": {
        "type": "text",
        "analyzer": "std"
      }
    }
  }
}

POST index_standard_analyzer/_analyze
{
  "field": "my_text", 
  "text": "The Standard Analyzer works this way. I love the standard analyzer for its tokenizing capacity"
}

PUT index_standard_analyzer_english_stopwords
{
  "settings": {
    "analysis": {
      "analyzer": {
        "std": { 
          "type": "standard",
          "stopwords": "_english_"
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "my_text": {
        "type": "text",
        "analyzer": "std"
      }
    }
  }
}
POST index_standard_analyzer_english_stopwords/_analyze
{
  "field": "my_text", 
  "text": "The Standard Analyzer works this way."
}

GET /_analyze
{
  "text": "Learning Elastic Stack 7",
  "analyzer": "standard"
}


PUT /custom_analyzer_index
{
  "settings": {
    "index": {
      "analysis": {
        "analyzer": {
          "custom_analyzer": {
            "type": "custom",
            "tokenizer": "standard",
            "filter": [
              "lowercase",
              "custom_edge_ngram"
            ]
          }
        },
        "filter": {
          "custom_edge_ngram": {
            "type": "edge_ngram",
            "min_gram": 2,
            "max_gram": 10
          }
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "product": {
        "type": "text",
        "analyzer": "custom_analyzer",
        "search_analyzer": "standard"
      }
    }
  }
}


POST /custom_analyzer_index/_doc
{
  "product": "Learning Elastic Stack 7"
}

POST /custom_analyzer_index/_doc
{
 "product": "Mastering Elasticsearch"
}
# auto complete feature 
GET /custom_analyzer_index/_search
{
 "query": {
   "match": {
     "product": "Ela"
   }
 }
}

GET /_cat/indices
GET /learn/_search
GET /learn/_mapping
GET /learn/_settings
GET /learn/_doc/_search

GET /learn/_search
{
   "_source": ["title"],
   "size": 20,
   "min_score": 0.5,
   "query": {
      "bool": {
         "must": [],
         "filter": [],
         "should": [
          {
           "match": {
             "title": "dick"
             
           }
          },
          {
           "match": {
             "title": "midnight"  
           }
          }
         ],
         "must_not": [{
           "bool":{
             "should":[
              {
                "match":{
                  "title":"run"
                }
              },
              {
                "match":{
                  "title":"diner"
                }
              }
              ]
           }
        }]
      }
   }
}

parent child relation

DELETE series
PUT series/
{
"mappings": {
 "properties": {
 "title":{"type": "keyword"}, 
 "film_to_franchise":{"type": "join","relations":{"franchise":"film"}
      }
    }
  }
}
DELETE series
GET series/_search
{
  "query": {
    "has_parent": {
      "parent_type": "franchise",
      "query": {
        "match": {
          "title": "Star Wars"
        }
      }
    }
  }
    
}

GET series/_search
{
  "query": {
    "has_child": {
      "type": "film",
      "query": {
        "match": {
          "title": "Star Wars: Episode IV - A New Hope"
        }
      }
    }
  }
}

GET movies/_search
{
  "query": {
    "match_all": {}
  }
}
POST movies/_update/135569
{
  "doc": {
    "year":2014
  }
}
POST movies/_doc/2020
{
  "doc":{
  "titel":"hello"
  }
}
GET movies/_doc/2020
DELETE movies/_doc/2020?pretty
GET movies/_search?q=love
PUT movies/_doc/20201
{
  "title":"krishna loves soni",
  "genre":["romantic", "love"],
  "year":2016
}
GET movies/_doc/20201
POST movies/_update/20201?retry_on_conflict=5
{
  "doc": {
    "home":"G05 lily block vijayasri elixir "
  }
}

DELETE krithahome/
PUT krithahome/
{
  "mappings":{
    "properties":{
      "name":{"type":"keyword"},
      "staying":{"type":"text"},
      "phone":{"type":"integer"},
      "nature":{"type":"text","analyzer": "english"}
    }
  }
}
DELETE movies

PUT movies/
{
  "mappings": {
    "properties": {
      "id":{"type": "integer"},
      "year":{"type":"date"},
      "genre":{"type":"keyword"},
      "title":{"type":"text","analyzer": "english"}
      
    }
  }
}
GET movies/_mapping
GET movies/_search

GET movies/_search?q=past
DELETE series
PUT series/
{
"mappings": {
 "properties": {
 "title":{"type": "keyword"}, 
 "film_to_franchise":{"type": "join","relations":{"franchise":"film"}
      }
    }
  }
}
DELETE series
GET series/_search
{
  "query": {
    "has_parent": {
      "parent_type": "franchise",
      "query": {
        "match": {
          "title": "Star Wars"
        }
      }
    }
  }
    
}

GET series/_search
{
  "query": {
    "has_child": {
      "type": "film",
      "query": {
        "match": {
          "title": "Star Wars: Episode IV - A New Hope"
        }
      }
    }
  }
}

#flattened mapping field, no analyzers or tokenizers are applied to this fields they are treated as a keyword match, main purpose is to reduce inner field mappings and there by preventing mapping explosion no highlighting feature(as no analysis)
GET _cluster/state

PUT demo-flatened
GET demo-flatened/_mapping
DELETE demo-flatened
PUT demo-flatened
{
  "mappings": {
    "properties": {
      "host":{"type": "flattened"}
    }
  }
}
GET demo-flatened/_mapping

POST demo-flatened/_doc
{
  "doc":{
    
    "message": "[5592:1:0309/123054.737712:ERROR:child_process_sandbox_support_impl_linux.cc(79)] FontService unique font name matching request did not receive a response.",
    "fileset": {
      "name": "syslog"
    },
    "process": {
      "name": "org.gnome.Shell.desktop",
      "pid": 3383
    },
    "@timestamp": "2020-03-09T18:00:54.000+05:30",
    "host": {
      "hostname": "bionic",
      "name": "bionic"
    }
  }
  
}
GET demo-flatened/_search
GET demo-flatened/_mapping

POST demo-flatened/_update/d0M3anwBv-Pt7pDf_vGN
{
  "doc": {
    "host":{
      "osVersion":"Bionic Server",
      "osArchitecture":"x86_64"
    }
    
  }
}

GET demo-flatened/_doc/d0M3anwBv-Pt7pDf_vGN
GET demo-flatened/_mapping

GET demo-flatened/_search
{
  "query": {
    "match": {
      "host": "Bionic Server"
    }
  }
}

GET demo-flatened/_search
{
  "query": {
    "match": {
      "host.osVersion": "Bionic Server"
    }
  }
}
GET demo-flatened/_search
{
  "query": {
    "match": {
      "doc.host.name": "Bionic"
    }
  }
}
GET demo-flatened/_search
{
  "query": {
    "match": {
      "doc.host.osVersion": "Server"
    }
  }
}

POST microservice-logs/_doc
{"doc":
{"timestamp": "2020-04-11T12:34:56.789Z", "service": "ABC", "host_ip": "10.0.2.15", "port": 12345, "message": "Started!" }
}
GET microservice-logs/_search

GET microservice-logs/_mapping

POST microservice-logs/_doc
{"doc":
{"timestamp": "2020-04-11T12:34:56.789Z", "service": "WiC", "host_ip": "10.3.2.15", "port": "6345", "message": "Started!" }
}


GET microservice-logs/_search


GET /microservice-logs/_close

GET /microservice-logs/_settings
### --data-raw '{
###    "index.mapping.ignore_malformed": true
### }'

GET /microservice-logs/_open

### 6.
GET /microservice-logs/_doc?pretty
### --data-raw '{"timestamp": "2020-04-11T12:34:56.789Z", "service": "XYZ", "host_ip": "10.0.2.15", "port": "NONE", "message": "I am not well!" }'

#mapping.ignored_malformed cant handle json object if the type field is difined as text
#so Payload field is used to handle JSON objects.

GET /microservice-logs/_doc?pretty
### --data-raw '{"timestamp": "2020-04-11T12:34:56.789Z", "service": "ABC", "host_ip": "10.0.2.15", "port": 12345, "message": "Received...", "payload": {"data": {"received":"here"}}}'
#here is anothe trap, ie if the payoad.data.received field nested or larger JSON data, we will face the mapping issue ie

GET /microservice-logs/_doc?pretty
### --data-raw '{"timestamp": "2020-04-11T12:34:56.789Z", "service": "ABC", "host_ip": "10.0.2.15", "port": 12345, "message": "Received...", "payload": {"data": {"received": {"even": "more"}}}}'
#we may face maper exception
#we have to be aware of this mapping fields and also establish shared guidelines  or 
#may even consider dead letter queue pattern, ie dlq, which will store the failed documents in a seperate queue, which may be handled at application level or may be handled at logstash dlq which still allows us to process the documents

#another caution is about mapping limit. by default the mapping limit is 1000, we may encounter illegal argument exception 
#increasing the mapping limit

curl XPUT 'http://localhost:9200/indexname/_settings -d '
{
  "index.mapping.total_fields.limit":1001
}'


PUT microservice-logs/_settings
{
  "index.mapping.total_fields.limit":1001
}
